\chapter{Music}
\section{Composition}
To create a sound accompaniment to the visual aspect we first need to consider
what style of music we should explore, that is to say, create at least an idea
of composition. Generative music is the technique we're exploring here, with
musical ideas being emergent from a set of parameters, and created from a system
that processes them. The definition is fairly vague as with generative art, the
main requirement is that a system is setup and creates the music, this doesn't
need to be a computer, but often is.

Generative music is rather recent, with Brian Eno being major figure
popularising its use, he would often use the analogy of a Moir\'{e} pattern to
describe how the programs would work at the time.  

The immediate style of music to draw from Viner's work would probably be that of
minimalism, the repetition and difference across an image is very similar in
style to especially the percussive works of Reich, Glass, Riley, and even the
drone works of La Monte Young to an extent. Another, less famous example that I
feel conveys the feeling well is \emph{Jon Gibson - Cycles (1977)}, the cover
for the recording is a Moir\'{e} pattern, and the work modulates a 7-note
pattern that comes into and out of phase with itself. 

In fact, Eno refers to his inspiration of generative music to be triggered by
hearing \emph{It's Gonna Rain} by Reich, linking generative music as a concept
pretty solidly to Minimalism. Reich used the analogy of fabric work and weaving,
featuring on the cover of Music for 18 Musicians is a woven piece of fabric;
this seems similar to the idea of a grid (given that weaving takes place on a
matrix of strings, perhaps the crossing points could be seen as `vertices')

There is also a nice parallel from the graphical scores of Xenakis to Viner's
works, at least aesthetically (see \autoref{xevicompare}). Xenakis is the
so-called `father of granular synthesis', this technique is made of playing many
small, short sounds (grains) to create what is often described as a `cloud' of
sound. Xenakis was also a pioneer of ideas of stochasticism in music and could
be said to be one of the first generative composers in that respect. 

\begin{figure}
    \centering
    \begin{subfigure}[t]{.49\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{metastasis-3}
        \caption*{\emph{Movement 3 of Xenakis' Metastasis}}
    \end{subfigure}
    \begin{subfigure}[t]{.49\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{viner2}
        \caption*{\emph{Darrell Viner, Untitled (1974)} \copyright Victoria and
    Albert Museum, London.}
    \end{subfigure}
    \caption{Comparison of Xenakis and Viner}
    \label{xevicompare}
\end{figure}


Overall the idea with the composition should be to enhance what is on the
screen, if the image is disordered the sound should be too, if it is ordered
and regular the sound should follow. 

An idea here is to use a kernel or convolution matrix to be able to take the
whole image's current parameters for each element in the grid and map it down to
a smaller dataset for use as parameters to the synthesiser, essentially
downscaling the image. This could be used powerfully with the idea of granular
synthesis as, for example each parameter could change something about a grain
(playback speed, volume, effect intensity). This feels also almost like the
feeling of the Moir\'{e} pattern mentioned by Eno. 

Further this will be combined with the methods mentioned in
\autoref{sonicnav}, including the ideas present in the mentioned minimalist
composers.

\section{Synthesis}
There are many options for digital synthesis of which I've already mentioned
granular synthesis, but frequency modulation, additive, wavetable, modal, and so
on are also options.

Largely there are four approaches, that of the Processed Recording, the Spectral
Model, the Physical Model, and the Abstract Algorithm \citep{smith_2005}.

For this project spectral and physical modelling are out of the scope and would
require more specialist audio software frameworks. Processed recording, includes
more sample-based audio and manipulation of that, granular synthesis is an
example. The 'abstract algorithm' methods include things like FM synthesis,
which in its most basic form is comprised of a carrier waveform who's frequency
is modulated by another waveform, this can be extended by things like including
feedback at various stages of the processing.

On top of these methods, there should also be a consideration to audio effects,
processing and p5.js both have sound libraries with built-in audio effects,
reverb and delay perhaps being the most important to create the idea of a space
in the sound.

Creating these methods in software are fairly straightforward when there is
already some digital signal processing in place; p5.js has a library called
\verb|Tone.JS| which handles a lot of the practical elements of sound
generation.

\section{Sequencing}
To create a sequence I considered a couple of options, to have a fixed note
sequence for example. This would perhaps be too static and not fit with the idea
of the project being generative art. Another simple option was to make notes
completely random, this tends to sound very `robotic' like a Sci-Fi movie
control panel. There could also be a random choice within a set of consonant
notes (i.e. that of a chord) this is a better idea because there's less chance
of a `bum note' (one that sounds out of place).

An extension of this idea is to use Markov Chains to model music in
\citep{ballstate2016} for example, they analyse Bach, Mozart, Palestrina, and
Beethoven to create a set of transition matrices for their chord progressions.
In this example chord progressions are used but the method can easily be adapted
to note progressions too. 

For my sequence I picked six possible tones, expressed as intervals from a base
tone, as $1, 1.2, 1.25, 1.5, 1.6, 2$ these represent unison, a minor third, a
major third, perfect fifth, and a minor sixth, and the octave (all
just-intonation). These tones were picked because they were the intervals in
5-limit that didn't have recurring decimals.\footnote{Ultimately this is arbitrary but
ends up fitting the definition of an augmented scale, this type of scale was
used more extensively in the 20th Century in Jazz, it was also used in Listz's
`Faust's Symphony'. Another way of thinking about it is two major triads above a
base pitch (e.g. C E G and E Eb Ab).} Each tone is also then affected by the
interval generated above to create a possible series of tones that depend on the
parameters of the program.

To create a Markov chain sequence first a matrix of probabilities that represent
the chain needs to be created. This defines the possible transitions between
notes and the probabilities of them, each row should add to give a total
probability of $1$. Changing the values in this matrix can therefore be thought
of as composing what series of tunes are possible and probable.

%TODO perhaps this needs updating eventually
\[
\begin{blockarray}{ccccccc}
    & 1 & 1.2 & 1.25 & 1.5 & 1.6 & 2\\
    \begin{block}{c (cccccc)}
        1    & 0  & 0.2& 0.5& 0.1& 0.1& 0.1\\
        1.2  & 0.1& 0  & 0.5& 0.1& 0.2& 0.2\\
        1.25 & 0.3& 0  & 0  & 0.6& 0.1& 0.1\\
        1.5  & 0.3& 0.2& 0.2& 0  & 0  & 0.2\\
        1.6  & 0.2& 0.2& 0.2& 0.3& 0  & 0.1\\
        2    & 0.4& 0.1& 0.2& 0.2& 0.1& 0  \\
    \end{block}
\end{blockarray}
\]

This represented in code becomes: 
\begin{lstlisting}[language=Javascript]
const markovObject = {
                        1:    [0  , 0.2, 0.5, 0.1, 0.1, 0.1],
                        1.2:  [0.1, 0  , 0.5, 0.1, 0.2, 0.2],
                        1.25: [0.3, 0  , 0  , 0.6, 0.1, 0.1],
                        1.5:  [0.3, 0.2, 0.2, 0  , 0  , 0.2],
                        1.6:  [0.2, 0.2, 0.2, 0.3, 0  , 0.1],
                        2:    [0.4, 0.1, 0.2, 0.2, 0.1, 0  ]
                    };
\end{lstlisting}

Using an object allows for fast lookup, then each index in the object refers to
an index of the keys of the object. So picking the next is simple, generate a
random number from 0 to 1 and then accumulate probability until we reach it:

\begin{lstlisting}[language=Javascript]
probList.forEach((e, i) => {
    if (picked >= acc && picked < acc + e) {
        intervalIndex = i;
    }
    acc += e;
});
\end{lstlisting}

Where \verb|probList| is the array referenced by the key of the current note in the
object and \verb|intervalIndex| is the index of the array of keys in the object.

Overall this is a very simple method for creating note sequences but is quite
effective for limiting the number of possible transitions with a lot of
flexibility.  
