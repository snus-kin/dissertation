\chapter{Recall}
\section{Saving the State}
To be able to recall past states a system needs to be in place that saves
parameters periodically. Every 100 frames a new `snapshot' of the state is
generated; this is an element in a JSON tree. Given the program is running at
around 60Hz (it is, however, not fixed) this means that approximately every 1.6
seconds the state is saved.

However, if we left the program running memory use would grow, so when saving
the state the program should check to see if it's changed or not. This has the
effect of compressing time in a neat way because you can interact with the
program, then step away and come back, begin interaction again and still be able
to use the recall as if there was no large gap between times.

The naive implementation of this is to create a json object that looks something
like this:

\begin{lstlisting}[language=javascript]
{
  "seed": 230128038,
  "uuid": 102830128,
  "elements": [
    {
      "x": 28,
      "y": 0,
      "z": 0,
      "noiseLevel": 0.4,
      "gridSpacing": 0.3
    },
    {
      "x": 31,
      "y": 10,
      "z": 0,
      "noiseLevel": 0.4,
      "gridSpacing": 0.3
    }
  ]
}
\end{lstlisting}

But, this approach of only using an array doesn't work, as when you `rewind'
you're actually branching from the progression that is ahead in the array. If
you only insert at the end of the array then this history gets mixed up leading
to a mess of non-chronological states.

So to fix this, a method using a tree should be devised. Each time you `rewind'
the tree should create a new branch from which you can begin control and
generate state elements in that branch. To do this I used the library 
\verb|Data-Tree|. This helps manage the tree structure by using references, and
can export and import the structure to and from JSON. The library also provides
methods to search and traverse the tree, operating on each node.

Exporting the tree to a file is then very simple, create a method that exports
the JSON tree and downloads it to the computer, the filename can be used to
store the seed. This works by creating a blob (binary large object), url to the
blob and then a link element that downloads the json file, then using JavaScript
to click the link and finally removing the link.

\section{Drawing and Interaction}
Drawing the tree to the screen requires traversal. If we use depth-first
traversal we can work out where a new branch is formed by checking if the depth
of the node is the previous node's depth plus one. Then we can simply move down
and draw a point. If not, we branch, however it becomes more complicated; at
every node we store the $(x,y)$ values into a json object with the key being the
node's unique key. Then when we see that the tree has branched we can find the
parent node (\verb|Data-Tree| stores this) and set the $y$ value to this and the
$x$ values increases by two times the diameter of the point. We then also need
to draw a line from the new branch's first node to the point where it branches,
this can be done by simply recalling the $x$ value of the parent node. Finally,
the most recent node is coloured red. In the end it looks like:

\begin{figure}[H]
    \centering
    \includegraphics[width=.2\textwidth]{tree}
    \caption{}
\end{figure}

To interact with the tree, each point is modelled as a button. These buttons
have a \verb|display()| method that checks if the mouse is hovering and then
draws a point. The point becomes twice the size if hovered and uses the key of
the node to check whether to make itself red or not. The button can be used to
check when the mouse is clicked if the button is hovered at the time of clicking
and then the state can be loaded.

\section{Recalling Parameters}
Recalling parameters is simple, when we know the key of the node to recall (from
the button that was clicked on) we can search the tree and then return the
values stored at that node. The program then sets each of the variables in the
main script to these values.

Importing a tree from json is similar, except we use \verb|Data-Tree| to import
the file into it's data structure first and then load the state at the last node
that was imported. We also call \verb|noiseSeed(filename)| (with the
\verb|.json| stripped) to set the seed correctly.

%% TODO hmm
%Since the state is only saved every 1.6 seconds but we want to have a 'fluid'
%method of playback, we can use a linear interpolation between two values in the
%tree. This can be found by letting the user choose a non-integer index and using
%\verb|p5js|'s \verb|lerp| function.
%
%% TODO change this to tree version
%\begin{lstlisting}[language=javascript]
%let ceil = Math.ceil(index);
%let floor = Math.floor(index);
%let ceilParams = this.logObj.elements[ceil];
%let floorParams = this.logObj.elements[floor];
%
%let t = index - floor;
%var state = {}
%//create elements in an intersitital state using lerp
%for (var key in ceilParams) {
%    state[key] = lerp(ceilParams[key], floorParams[key], t);
%}
%\end{lstlisting}
%
%This, of course, assumes that the user is moving linearly between states which
%may be the case if they're just holding buttons down. Other methods of
%interpolation could be considered, but for the increased computing cost of a
%polynomial interpolation or spline interpolation and the fact that users are
%unlikely to be moving in a way that either of these methods could fit either.
%For example if the user decides to move back-and-forth between two steps there
%is no way to recover that data. Ultimately the user's inputs will never be able
%to be modelled by interpolation; this method however saves having to keep the
%state every frame, and is `good enough' to recall a previous state as likely the
%user cannot remember the exact configuration anyway.
