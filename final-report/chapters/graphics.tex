\chapter{Graphics}

There are two problems to consider here, how points on a grid are generated, and
how they are displayed. To generate points there needs to be a method of
procedural generation, i.e. creating an algorithm that can given a set of
parameters tell me where a point should or shouldn't be and what other points it
should or shouldn't connect to.

The problem of how they are displayed is another issue, how can we convey the
idea of moving through a space when the space is simply a grid? The points must
move smoothly between configurations to give the illusion of being in a
landscape rather than that of a series of static images.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{flatlandsphere}
    \caption{Figure reproduced from Flatland \citep[p.112]{abbott1885flatland}}
\end{figure}

The landscape is not just 2D, parameters each constitute a dimension, when one is
changing we see a 2D slice of the multi-dimensional world as in the book
`Flatland' ``You cannot indeed see more than one of my sections, or Circles, at
a time; for you have no power to raise your eye out of the plane of Flatland;
but you can at least see that, as I rise in Space, so my sections become
smaller. See now, I will rise; and the effect upon your eye will be that my
Circle will become smaller and smaller till it dwindles to a point and finally
vanishes.'' \citep[p.112]{abbott1885flatland} A shape (polygon in this instance,
sphere in the book) cuts through the plane to show `slices' of itself. Here we
are in `flatland' and the parameter space we create allows us to see the work as
slices of a higher-dimensional shape (than 2D). 

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{3d}
    \caption{Here the `z' parameter increases, each `layer' is transformed
    between smoothly}
\end{figure}

\section{Anatomy of the Work}
Viner's pen plotter work was created by a set of programs, created in
\verb|FORTRAN| using a set of subroutines called \verb|PICASO| (PIcture Computer
Algorithms SubroutineOriented) \citep{lycett_2016}, this was essentially a
line-drawing library, similar to what we are using processing / p5js for.
\verb|PICASO|'s use by Viner isn't well documented but the manual
\citep{picaso_manual} has many subroutines for transforming vertices according
to some rules. Some notes on Viner's work indicate there was definitely
mathematical thinking going on in the development.

\section{Polygons}
\label{Polygons}
One aspect the program should be able to do is to grow and shrink polygons
between different number of verticies. Viner's work uses many different number
of verticies between images, so we should be able to reproduce this by allowing
a smooth transition between polygons. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{triangleViner}
    \hspace{0.2cm}
    \includegraphics[width=0.45\textwidth]{octagonViner}
    \caption{Two viner showing the use of polygons}
\end{figure}


To achieve this a polygon is inscribed on a circle. The points of this polygon
of $n$ verticies on the circle are simply given by $$(x, y) = (\cos(\frac{2k
\pi}{n}), \sin(\frac{2k\pi}{n})) \text{ where } k = 0, 1, \ldots, \lfloor n
\rfloor$$ 

We can note that for integer values of $n$ the rotation will be complete, for
non-integer values of $n$ this also works given that we used the floor of $n$ as
the limit giving us an incomplete polygon, we can use the fact we have the first
coordinate to close the shape. This gives us the smooth transition between
integer values of $n$.

% figure showing this
\begin{figure}[H]
    \centering
    \includegraphics[width=0.2\textwidth]{n4}
    \includegraphics[width=0.2\textwidth]{n35}
    \includegraphics[width=0.2\textwidth]{n32}
    \includegraphics[width=0.2\textwidth]{n3}
    \caption{Starting at $n=4$ the shape deforms through $n=3.5$, $n=3.2$ and
    finally $n=3$}
\end{figure}

In code we can implement this as such:
\begin{lstlisting}[language=JavaScript]
// center
let x = innerWidth/2;
let y = innerHeight/2;
let n = 4;
let r = 300;

let theta = 3*QUARTER_PI;
dTheta = TWO_PI/n;

beginShape()
    vertex(x + r*cos(theta), y + r*sin(theta));
    for (i = 1; i <= n; i++) {
        theta += dTheta;
        vertex(x + r*cos(theta), y + r*sin(theta));
    }
endShape(CLOSE);
\end{lstlisting}

An offset to each $(x,y)$ pair can be made, calculated within the for loop, to
transform the shape away from regular polyhedra (when $n$ is an integer).

\section{The Grid}
With the motif of the grid being the most obvious visible thing in Viner's art,
there needs to be a way to actually draw a grid to the screen; ideally each
vertex needs to be able to be separately controlled.

To do this I have adapted John Stell's work on Viner in his workshops
\cite{stell_unpublished}, using an object-oriented approach; but have created a
system where the grid is centred on a given \verb|x,y| coordinate. Essentially
there is a screen, and for every vertex at a column and row their relative
coordinates need to be calculated. This is simple with the following statement:



%the immediate issue here is that we want the grid to be drawn from the center out.
%How can we do this? A spiral? A space filling curve? We can't really
%have negative indicies to lists.
%
%Create a seperate notion of 'columns' and 'rows' that draw and x and y
%are infinite and inform what is to be rendered in those columns and rows
%
%How many columns and rows do we need? We define a grid size and it's n *
%that How do we map x and y to this notion? We have a grid size so we can
%work out how many are shown at a time, how to ensure that we are always
%in the center?  Perhaps this means we don't actually need to worry about
%where we are just what is rendered based on this. thus we let our x and
%y values determine what is immediately under us but the rest of the
%image renders around this

%for now at least I want to be able to draw points at a (x, y) dependant
%offset from the center of each point?
%
%center the grid on whatever x and y value we're at right now

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[language=java]
sx = (x + (gridSize * ((cols/2) - i)));
sy = (y + (gridSize * ((rows/2) - j)));
\end{lstlisting}
\end{tabular}
\end{center}

Where \verb|i,j| is the column and row value of the point, \verb|cols,rows|
are the total number of columns and rows, and \verb|gridSize| is the pixel size
of the grid (which is more of a guide than anything). The grid should also
be centred on \verb|x,y| so calling a translate before drawing any points should
be done:

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[language=java]
translate((width/2)+(0-x), (height/2)+(0-y));
\end{lstlisting}
\end{tabular}
\end{center}

All of this leads to a system where the centre point has a given coordinate and
we can find that coordinate for all other points around it, this also means we
can interpolate any parameters from the program to what should be expected at a
given coordinate; or we can also generate a terrain away from the main graphics
thread and draw them to the screen at a given coordinate.

\subsection{Demo}
Here a grid is prepared with fixed parameters that create distortion around
\verb|x=0, y=0|. This point is fixed, and when the program is interacted with
the world moves beneath the player rather than the point of distortion being
changed, the grid displayed is reflecting the `terrain' visible from the centre
point.

\begin{figure}[H]
\centering
\includegraphics[width=.4\textwidth]{PoC3}
\hspace*{0.5cm}
\includegraphics[width=.4\textwidth]{PoC2}
\caption{The user presses `a' for a short time, decreasing the `x' parameter}
\label{demomovement}
\end{figure}

\section{Landscape Generation}
\label{landgen}
% Talk about landscape analogy
The program should generate a `landscape' or `topology', this is an analogy for
a space that has an continuous change of the parameters across them. `Landscape'
is apt because we're exploring a set of features generated by the program much
like if you were to look at a topographic map. The user should have the feeling
of moving through a space like this, more than simply increasing some parameter
and immediately seeing a change throughout the grid.

% Talk about explorations into proc gen, dynamical systems etc.
This is the main question of how the program will work on a technical level, how
can we create an algorithm or mathematical model that explores the spaces that
Viner's work set out to create?

Dynamical systems may be of interest, and allow for a system to be created where
a state evolves into other states following some rules. These states can be
deterministic which is important for the objective that we have of recall, but
can also be chaotic, which may be aesthetically desirable.

Similarly, fractals may be useful for their self-similarity. Given we're working
with a grid, the ability to have self-similar properties may be considered to be
aesthetically useful.

This leads to the choice between having each session using the software be
either random in some sense or the same every time. Ideally given a random
option to fulfil the ability to recall previous sessions, a seed would be given.
It seems then that the random choice contains the static choice and should be
the one to be carried out.

\subsection{Noise}
One possible function to consider here is a computer-graphics oriented noise
implementation. A desireable property is that of a fairly smooth gradient
between extremes, or defined regions in which values are high.

\verb|p5js|'s built-in noise function is a perlin noise generator. You can pass
it up to three coordinates. Perlin noise was designed for computer graphics
\footnote{And won an Oscar for "allow[ing] computer graphics artists to better
represent the complexity of natural phenomena" \citep{nyu_perlin}}, and is relatively simple,
generating a random grid of vectors and then computing the dot product vectors
and their offsets, then finally interpolating to create a more smooth image
\citep{10.1145/566570.566636}.

\verb|p5js| also provides a \verb|noiseDetail()| method that provides some
control over the 'texture' of the noise. Also for reproducibility
\verb|noiseSeed()| allows the programmer to set a seed value for the noise.
The \verb|noise()| function takes three coordinate arguments and outputs a
number between $0-1$

\begin{figure}[H]
\centering
\includegraphics[width=.4\textwidth]{noiseDefault}
\hspace{0.2cm}
\includegraphics[width=.4\textwidth]{noiseDetail2halfFalloff}
\caption{Two perlin noise samples (one default the other with
noiseDetail(2, 0.5) with the same seed, histograms plotted beneath show
that the adjustment makes the image overall darker}
\end{figure}

One option we may wish to be able to have is `quantising' the noise to some set
of values. For example we may wish to have areas of a certain value of $n$ for a
polygon. This can be achieved by mapping the noise from $0-1$ to $0-n$ and
rounding to the closest integer. This was happening implicitly with the
histogram above. We can see that because the distribution is unimodal the most
common values will be those towards the center of the range.

\begin{figure}[H]
\centering
\includegraphics[width=.4\textwidth]{noiseQuantised}
\caption{This sample contains only ten colours}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.4\textwidth]{noiseScaleUnquantised}
\hspace{0.2cm}
\includegraphics[width=.4\textwidth]{noiseScaleQuantised}
\caption{Unquantised and quantised noise at 0.001 noiseScale}
\label{0.001scale}
\end{figure}

This effect is much more obvious when the noise scale is a lot smaller, this
would then allow for discrete regions between two integer values for a
parameter. What if we don't want discrete regions and instead something more
like a multimodal distribution i.e. smoothing applied between edges?

We can use a waveform such as the sawtooth to achieve `smoothing' by using it to
estimate rounding, adding the value to the wave produces something approximating
the `staircase' function of piece-wise rounding. To do this we can use additive
synthesis:

$$x + \frac{1}{\pi} (-\sum^\infty_{k=1} \frac{\sin(2k \pi x)}{k})$$

To use this in code we take only some number of terms, this determines the
accuracy of the rounding, the lower the more `smooth', i.e. inexact the output:
\begin{lstlisting}[language=JavaScript]
function approx_round(value, terms) {
    let result = value;
    
    var innerSum = -sin(2 * PI * value);
    for (i = 2; i <= terms; i++)
        innerSum += (sin((i * 2) * PI * value) / i)

    result += innerSum / PI;

    return result;
}
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=.2\textwidth]{noiseRounded}
\hspace{0.2cm}
\includegraphics[width=.2\textwidth]{noiseAlmostRounded100}
\hspace{0.2cm}
\includegraphics[width=.2\textwidth]{noiseAlmostRounded20}
\hspace{0.2cm}
\includegraphics[width=.2\textwidth]{noiseAlmostRounded1}
\caption{Rounded discretely, Terms = 100, Terms = 20, Terms = 1}
\end{figure}

At such a large scale the difference is hard to percieve but when using the
example in \autoref{0.001scale} there's a clear `smoothing' in the boundaries.

\begin{figure}[H]
\centering
\includegraphics[width=.3\textwidth]{noiseScaleAlmost}
\hspace{0.2cm}
\includegraphics[width=.3\textwidth]{noiseScaleAlmost10}
\hspace{0.2cm}
\includegraphics[width=.3\textwidth]{noiseScaleAlmost1}
\caption{Terms = 100, Terms = 10, Terms = 1}
\end{figure}

Implmenting this such that noise controlls the number $n$ (verticies in a
polygon) we can get results like this (note that the background is shaded darker
for lower values of $n$ and lighter for higher values of $n$)
\begin{figure}[H]
\centering
\includegraphics[width=.4\textwidth]{noisewithPolygons}
\hspace{0.2cm}
\includegraphics[width=.4\textwidth]{noisewithPolygons1term}
\caption{Terms = 20, Terms = 1}
\end{figure}

With user interaction this scheme creates the feeling of moving through regions
of these differernt values of $n$ and the parameter for the number of terms
allows for adjustments to be made about how `hard' or `soft' the borders between
these regions look.

This approach is, I believe somewhat novel, as most techniques for adjusting
noise is usually done at a whole-image level. This method is point-wise and thus
can work for each polygon or vertex in the grid we have defined. In the field of
signal processing the concept of `quantisation noise' is similar but reversed,
taking a contiuous signal and analysing the error in the digital discrete
signal. Here we are designing a function for an artistic application, and I do
not think that it has application to the field of signal processing as it works
on discrete to discrete transformations and not continous to discrete.

\section{Navigation}
%TODO write about higher-dimenionality
Navigating higher-dimensional space is of practical interest because a lot of
data is higher-dimensional, for example the field of machine learning for
example deals with very high dimensional data. Tools like `\verb|ggobi|' exist
to help explore multi-variate data \citep{swayne:dsc2003} which tend to
disregard spacial relations of points in favour of clustering based on shared
properties. A novel method is that of the grand tour, through which a series of
scatter plots are projected orthogonally into 2D subspaces from the
higher-dimensional space and moved then between continuously to describe
multi-variate data \citep{asimov1985grand}.

Whilst these approaches are useful for data, what we're dealing with here is
generating spaces to explore, these spaces are less about trends in data and
more about geometric exploration through many continuous parameters.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{marioturns}
    \caption{Mario turns $90^\circ$ around the z-axis (\emph{Super Paper Mario
    (2007) pub. Nintendo})}
\end{figure}

Video games also have explored higher-dimensional spaces. An
interesting concept is that of 2D characters being able to navigate 3D spaces.
\emph{Super Paper Mario (2007)} for the Nintendo Wii is an example of this, the
player can turn the world 90 degrees about the y-axis to explore the depth of
the z-axis and progress through the game. An extension of this from a 3D
character turning 90 degrees and being able to explore a 4th Dimension is
present in the unreleased game \emph{Miegakure} in which the player can move
through the 4th Dimension using the controller, to help orient the player a
graphic\footnote{Which the developer tells me is based on an astrolabe} is
displayed below the controlled character showing the position of the slice of
the 4D world, these slices are like the 2D slices we can see in MRI imaging but
in 3D.

Whilst these worlds explore pre-made or procedurally generated assets (models,
textures, sprites, etc.), and this program instead will explore moving through
various parameters, ideas for how the user can interface with the program to
understand where exactly they are.

\subsection{Graphical Prompts}
A simple idea to allow the user to recall where in the parameter space they were
could be a spider / radar plot, or parallel coordinates plot. For our intents these
are the same as we're only displaying a single set of parameters the spider plot
is just a `round' version of the parallel coordinates plot. This could exist on
the screen somewhere and change as the user moved around the parameter space,
and would allow the user to recall approximately where they were. The spider
diagram could also be `extruded' from how it looked at every point to create a
3D model that represented how you moved through the parameters.

\subsection{Controls}
The above mentioned video games allow for the user to move through the space by
only letting the user worry about at most 3 dimensions at any one time, and
regarding the others as static when moving through them, this allows the user to
control the movement with traditional controls (either a games controller or
keyboard and mouse).

In \autoref{demomovement}, the \verb|WASD| style of control, popular in video
games is used. This will be familiar to people who have played video games but
not to people who haven't, for whom it may make sense to use the arrow keys.
It's also important to note that in that particular demo the `d' key increases
\verb|x|, this gives the feeling that the world is moving `beneath' you instead
of you moving the world itself; if the controls were flipped such that `d'
decreased \verb|x|, it would instead feel like you were moving the world. 

Another option would be something like an array of knobs, these could encode one
parameter each, and like a scientific instrument be `tuned'. However this relies
on specialist hardware. This would probably feel less like `moving' through a
space and more exploring a range of possibilities.

\section{User Interface}
The final graphical element to consider is how the user interacts with the HTML
elements that control various functions. I created: an upload and download button
for interaction with the history; a mute button and volume slider for the audio;
and a help screen that explains the key controls and what the program is.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{webinterface}
    \caption{Web interface with buttons}
\end{figure}

I decided to keep the buttons simple, and without text so as to not distract
from the main graphical part of the program. They also animate when the user
hovers over them (they gain a black border and grey background) to indicate they
are able to be clicked.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{helpmenu}
    \caption{Help menu}
\end{figure}

The help menu expands when the `?' button in the top right is hovered and
retracts when the user un-hovers the help menu. The background is slightly
transparent so as to not block the rest of the program. I produced a graphic of
a keyboard to help explain where the keys are located on the users computer and
a flex-box list of keys (that adapt to different screen widths). I also included
a short explaination of how the history tree works and what the audio controls
do.
