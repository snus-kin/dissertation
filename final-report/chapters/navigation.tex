\chapter{Navigating Higher-dimensional Space}
%TODO get rid of this chapter I think
\section{Graphically}
Navigating higher-dimensional space is of practical interest because a lot of
data is higher-dimensional, for example the field of machine learning for
example deals with very high dimensional data. Tools like `\verb|ggobi|' exist
to help explore multi-variate data \citep{swayne:dsc2003} which tend to
disregard spacial relations of points in favour of clustering based on shared
properties. %liu_2015

Whilst these approaches are useful for data, what we're dealing with here is
generating spaces to explore, these spaces are less about trends in data and
more about geometric exploration through many continuous parameters.

Video games also have explored non-euclidean and higher-dimensional spaces. An
interesting concept is that of 2D characters being able to navigate 3D spaces.
\emph{Super Paper Mario (2007)} for the Nintendo Wii is an example of this, the
player can turn the world 90 degrees about the y-axis to explore the depth of
the z-axis and progress through the game. An extension of this from a 3D
character turning 90 degrees and being able to explore a 4th Dimension is
present in the unreleased game \emph{Miegakure} in which the player can move
through the 4th Dimension using the controller, to help orient the player a
graphic \footnote{Which the developer tells me is based on an astrolabe} is
displayed below the controlled character showing the position of the slice of
the 4D world, these slices are like the 2D slices we can see in MRI imaging but
in 3D.

Whilst these worlds explore pre-made or procedurally generated assets, and this
program instead will explore moving through various parameters, ideas for how
the user can interface with the program to understand where exactly they are.

\subsection{Graphical Prompts}
A simple idea to allow the user to recall where in the parameter space they were
could be a spider / radar plot, or parallel coordinates plot. For our intents these
are the same as we're only displaying a single set of parameters the spider plot
is just a `round' version of the parallel coordinates plot. This could exist on
the screen somewhere and change as the user moved around the parameter space,
and would allow the user to recall approximately where they were. The spider
diagram could also be `extruded' from how it looked at every point to create a
3D model that represented how you moved through the parameters.

\subsection{Controls}
The above mentioned video games allow for the user to move through the space by
only letting the user worry about at most 3 dimensions at any one time, and
regarding the others as static when moving through them, this allows the user to
control the movement with traditional controls (either a games controller or
keyboard and mouse).

In \autoref{demomovement}, the \verb|WASD| style of control, popular in video
games is used. This will be familiar to people who have played video games but
not to people who haven't, for whom it may make sense to use the arrow keys.
It's also important to note that in that particular demo the `d' key increases
\verb|x|, this gives the feeling that the world is moving `beneath' you instead
of you moving the world itself; if the controls were flipped such that `d'
decreased \verb|x|, it would instead feel like you were moving the world. 

Another option would be something like an array of knobs, these could encode one
parameter each, and like a scientific instrument be `tuned'. However this relies
on specialist hardware. This would probably feel less like `moving' through a
space and more exploring a range of possibilities.

\subsection{Visualising Possible Shapes}
As in \cite{swayne:dsc2003} we could possibly plot sub-spaces of a shape to
create a visualisation of the `configuration space'. That is, where there are a
potentially infinite (practically until overflow) variation in parameters there
is a parameter space. But when we apply functions to limit this space we create
a `configuration space'.

\section{Recall}
To be able to recall past states a system needs to be in place that saves
parameters periodically. Every 100 frames a new `snapshot' of the state is
generated; this is an element in a JSON tree. Given the program is running at
around 60Hz (it is, however, not fixed) this means that every 1.6 seconds the
state is saved.

However, if we left the program running memory use would grow, so when saving
the state the program should check to see if it's changed or not. This has the
effect of compressing time in a neat way because you can interact with the
program, then step away and come back, begin interaction again and still be able
to use the recall as if there was no large gap between times.

The first implementation of this was to create a json object that looked
something like this:

\begin{lstlisting}[language=javascript]
{
  "seed": 230128038,
  "uuid": 102830128,
  "elements": [
    {
      "x": 28,
      "y": 0,
      "z": 0,
      "noiseLevel": 0.4,
      "gridSpacing": 0.3
    },
    {
      "x": 31,
      "y": 10,
      "z": 0,
      "noiseLevel": 0.4,
      "gridSpacing": 0.3
    }
  ]
}
\end{lstlisting}

But, this approach of only using an array doesn't work, as when you `rewind'
you're actually branching from the progression that is ahead in the array. If
you only insert at the end of the array then this history gets mixed up leading
to a mess of non-chronological states.

So to fix this, a method using a tree should be devised. Each time you `rewind'
the tree should create a new branch from which you can begin control and
generate state elements in that branch.

% tree

Since the state is only saved every 1.6 seconds but we want to have a 'fluid'
method of playback, we can use a linear interpolation between two values in the
tree. This can be found by letting the user choose a non-integer index and using
\verb|p5js|'s \verb|lerp| function.

% TODO change this to tree version
\begin{lstlisting}[language=javascript]
let ceil = Math.ceil(index);
let floor = Math.floor(index);
let ceilParams = this.logObj.elements[ceil];
let floorParams = this.logObj.elements[floor];

let t = index - floor;
var state = {}
//create elements in an intersitital state using lerp
for (var key in ceilParams) {
    state[key] = lerp(ceilParams[key], floorParams[key], t);
}
\end{lstlisting}

This, of course, assumes that the user is moving linearly between states which
may be the case if they're just holding buttons down. Other methods of
interpolation could be considered, but for the increased computing cost of a
polynomial interpolation or spline interpolation and the fact that users are
unlikely to be moving in a way that either of these methods could fit either.
For example if the user decides to move back-and-forth between two steps there
is no way to recover that data. Ultimately the user's inputs will never be able
to be modelled by interpolation; this method however saves having to keep the
state every frame, and is `good enough' to recall a previous state as likely the
user cannot remember the exact configuration anyway.

% plot example?
